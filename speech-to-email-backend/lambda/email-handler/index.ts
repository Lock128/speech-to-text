import { Context } from 'aws-lambda';
import { SESClient, SendEmailCommand } from '@aws-sdk/client-ses';
import { DynamoDBClient, UpdateItemCommand } from '@aws-sdk/client-dynamodb';

const sesClient = new SESClient({ region: process.env.AWS_REGION });
const dynamoClient = new DynamoDBClient({ region: process.env.AWS_REGION });

interface EmailPayload {
  transcriptionText: string;
  originalFileName: string;
  timestamp: string;
  recordId: string;
}

export const handler = async (event: EmailPayload, context: Context) => {
  console.log('Email handler triggered:', JSON.stringify(event, null, 2));

  const { transcriptionText, originalFileName, timestamp, recordId } = event;
  const maxRetries = 3;
  let retryCount = 0;

  while (retryCount < maxRetries) {
    try {
      // Format the email content
      const subject = `Speech to Email: ${originalFileName} - ${new Date(timestamp).toLocaleString()}`;
      
      const htmlBody = `
        <html>
          <head>
            <style>
              body { font-family: Arial, sans-serif; line-height: 1.6; color: #333; }
              .header { background-color: #f4f4f4; padding: 20px; border-radius: 5px; margin-bottom: 20px; }
              .content { padding: 20px; }
              .transcription { background-color: #f9f9f9; padding: 15px; border-left: 4px solid #007bff; margin: 20px 0; }
              .footer { font-size: 12px; color: #666; margin-top: 30px; padding-top: 20px; border-top: 1px solid #eee; }
              .metadata { background-color: #e9ecef; padding: 10px; border-radius: 3px; margin-bottom: 20px; }
            </style>
          </head>
          <body>
            <div class="header">
              <h2>ðŸŽ¤ Speech to Email Transcription</h2>
            </div>
            
            <div class="content">
              <div class="metadata">
                <strong>File:</strong> ${originalFileName}<br>
                <strong>Recorded:</strong> ${new Date(timestamp).toLocaleString()}<br>
                <strong>Record ID:</strong> ${recordId}<br>
                <strong>Processed:</strong> ${new Date().toLocaleString()}
              </div>
              
              <h3>Transcription:</h3>
              <div class="transcription">
                ${transcriptionText || 'No transcription available'}
              </div>
              
              <div class="footer">
                <p>This email was automatically generated by the Speech to Email application.</p>
                <p>If you have any questions or issues, please contact your system administrator.</p>
              </div>
            </div>
          </body>
        </html>
      `;

      const textBody = `
Speech to Email Transcription

File: ${originalFileName}
Recorded: ${new Date(timestamp).toLocaleString()}
Record ID: ${recordId}
Processed: ${new Date().toLocaleString()}

Transcription:
${transcriptionText || 'No transcription available'}

---
This email was automatically generated by the Speech to Email application.
      `;

      // Send email using SES
      const sendEmailCommand = new SendEmailCommand({
        Source: process.env.SENDER_EMAIL,
        Destination: {
          ToAddresses: [process.env.RECIPIENT_EMAIL!],
        },
        Message: {
          Subject: {
            Data: subject,
            Charset: 'UTF-8',
          },
          Body: {
            Html: {
              Data: htmlBody,
              Charset: 'UTF-8',
            },
            Text: {
              Data: textBody,
              Charset: 'UTF-8',
            },
          },
        },
        ConfigurationSetName: 'speech-to-email-config-set',
      });

      const result = await sesClient.send(sendEmailCommand);
      console.log('Email sent successfully:', result.MessageId);

      // Update DynamoDB record with success status
      const updateCommand = new UpdateItemCommand({
        TableName: process.env.DYNAMODB_TABLE_NAME,
        Key: {
          PK: { S: recordId },
          SK: { S: 'RECORD' },
        },
        UpdateExpression: 'SET #status = :status, emailSentAt = :emailSentAt, updatedAt = :updatedAt, emailMessageId = :messageId',
        ExpressionAttributeNames: {
          '#status': 'status',
        },
        ExpressionAttributeValues: {
          ':status': { S: 'email_sent' },
          ':emailSentAt': { S: new Date().toISOString() },
          ':updatedAt': { S: new Date().toISOString() },
          ':messageId': { S: result.MessageId || 'unknown' },
        },
      });

      await dynamoClient.send(updateCommand);
      console.log(`Updated record status to email_sent for ${recordId}`);

      return {
        statusCode: 200,
        body: JSON.stringify({
          message: 'Email sent successfully',
          messageId: result.MessageId,
          recordId,
        }),
      };

    } catch (error) {
      retryCount++;
      console.error(`Email sending attempt ${retryCount} failed:`, error);

      if (retryCount >= maxRetries) {
        // Update DynamoDB record with failure status
        try {
          const updateCommand = new UpdateItemCommand({
            TableName: process.env.DYNAMODB_TABLE_NAME,
            Key: {
              PK: { S: recordId },
              SK: { S: 'RECORD' },
            },
            UpdateExpression: 'SET #status = :status, errorMessage = :error, updatedAt = :updatedAt, retryCount = :retryCount',
            ExpressionAttributeNames: {
              '#status': 'status',
            },
            ExpressionAttributeValues: {
              ':status': { S: 'failed' },
              ':error': { S: error instanceof Error ? error.message : 'Email sending failed' },
              ':updatedAt': { S: new Date().toISOString() },
              ':retryCount': { N: retryCount.toString() },
            },
          });

          await dynamoClient.send(updateCommand);
          console.log(`Updated record status to failed after ${retryCount} retries for ${recordId}`);
        } catch (updateError) {
          console.error('Error updating failed record:', updateError);
        }

        throw error;
      }

      // Wait before retry (exponential backoff)
      const waitTime = Math.pow(2, retryCount) * 1000; // 2s, 4s, 8s
      console.log(`Waiting ${waitTime}ms before retry ${retryCount + 1}`);
      await new Promise(resolve => setTimeout(resolve, waitTime));
    }
  }

  // This should never be reached due to the throw in the catch block
  return {
    statusCode: 500,
    body: JSON.stringify({ message: 'Unexpected error in email handler' }),
  };
};